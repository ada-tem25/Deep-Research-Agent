import os
from datetime import datetime
from langgraph.graph import StateGraph
from langgraph.graph import add_messages
from langchain_core.messages import BaseMessage, SystemMessage, HumanMessage, AIMessage
from langgraph.graph import START, END
from typing import TypedDict, Annotated, Sequence, List
from pydantic import BaseModel, Field
from langchain_google_genai import ChatGoogleGenerativeAI
import operator
from dotenv import load_dotenv
load_dotenv()

from prompts import (query_writer_instructions)
from tools import get_research_topic



# ------------- Graph Initialization ----------------

class OverallState(TypedDict): #All the fields that the state will keep in memory between nodes, and how they are modified (add_messages / operator.add)
    messages: Annotated[list, add_messages] #conversation history
    search_query: Annotated[list, operator.add] #the search queries that will be generated by the first node
    web_research_result: Annotated[list, operator.add] #all the search results
    sources_gathered: Annotated[list, operator.add] #all the sources gathered
    initial_search_query_count: int
    max_research_loops: int #limit of research loops
    research_loop_count: int #count of research loops
    reasoning_model: str

builder = StateGraph(OverallState) #create a graph, with the above state as its referred state



# --------- 1st node : Generate Search Queries -----------

class Query(BaseModel):
    query: str = Field(
        description="One of the queries necessary to the web research."
    )
    rationale: str = Field(
        description="A brief explanation of why these queries are relevant to the research topic." #It allows to audit the behaviour of the agent
    )

class SearchQueries(BaseModel):
    queries: list[str] = Field(
        description="A list of search queries to be used for web research."
    )
    rationale: str = Field(
        description="A brief explanation of why these queries are relevant to the research topic."
    )

class QueryGenerationState(TypedDict): #the ouput node-specific state
    queries: list[Query]


def generate_query(state: OverallState) -> QueryGenerationState:
    """LangGraph node that generates search queries 
       based on the User's question. Uses Gemini 2.0 Flash.

    Args:
        state: Current graph state containing the User's question

    Returns:
        Dictionary with state update, including the list of the generated queries
    """

    #We configure the model
    llm = ChatGoogleGenerativeAI(
        model="gemini-2.0-flash",
        temperature=1,
        max_retries=2,
        api_key=os.getenv("GOOGLE_API_KEY"),
    )
    llm = llm.with_structured_output(SearchQueries) #constrains the model to return an output conforming to the format of SearchQueryList

    #We adapt the prompt
    formatted_prompt = query_writer_instructions.format(
        current_date=datetime.now().strftime("%B %d, %Y"),
        research_topic=get_research_topic(state["messages"]), #This function retrieves the AI and human messages from the conversation to understand the research topic
        number_queries=state["initial_search_query_count"],
    )

    result = llm.invoke(formatted_prompt) #At this point, result is of format {queries: List(str), rationale: str} (like SearchQueries)
    queries = [Query(query=q, rationale=result.rationale) for q in result.queries]
    return {"queries": queries} #Returns a QueryGenerationState {queries: List(Query)} with Query being {query: str, rationale: str}

builder.add_edge(START, "generate_query") #this node is the first one called
builder.add_node("generate_query", generate_query)



#----------------- 1st conditional edge : parallel searches ----------

def continue_to_web_research(state: QueryGenerationState):
    # ...Some logic to send out multiple search queries...
    return None

builder.add_conditional_edges("generate_query", continue_to_web_research, ["web_research"])


# ------------- 2nd node : Web Research ---------------

class WebSearchState(TypedDict):
    search_query: str
    id: str

def web_research(state: WebSearchState) -> OverallState:
    # ...Some logic to performs web research...
    return {
        "search_query": [state["search_query"]], #Those are actual fields from the OverallState : the operators at the top define how they will be merged in the shared OverallState
        #"web_research_result": [modified_text],
        #"sources_gathered": sources_gathered,
    }

# Reflect on the web research
builder.add_node("web_research", web_research)
builder.add_edge("web_research", "reflection")

# ------------- 3rd node : Reflection ---------------

class ReflectionState(TypedDict):
    is_sufficient: bool
    knowledge_gap: str
    follow_up_queries: Annotated[list, operator.add]
    research_loop_count: int
    number_of_ran_queries: int

def reflection(state: OverallState) -> ReflectionState:
    # ...Some logic to reflect on the results...
    result = {}
    return {
        "is_sufficient": result.is_sufficient,
        "knowledge_gap": result.knowledge_gap,
        "follow_up_queries": result.follow_up_queries,
        "research_loop_count": state["research_loop_count"],
        "number_of_ran_queries": len(state["search_query"]),
    }

builder.add_node("reflection", reflection)


#----------------- 2nd conditional edge : is context sufficient? ----------

def evaluate_research(state: ReflectionState) -> OverallState:
    # ...Some logic to determine the next step in the research flow...
    return None

builder.add_conditional_edges("reflection", evaluate_research, ["web_research", "finalize_answer"])


# ----------------- 4th node : Finalizing Answer ------------------


def finalize_answer(state: OverallState) -> OverallState:
    # ...Some logic to finalize the research summary...

    result = {}
    return {
        "messages": [AIMessage(content=result.content)],
        #"sources_gathered": unique_sources,
    }

builder.add_node("finalize_answer", finalize_answer)


# ----------------- Graph End ------------------

builder.add_edge("finalize_answer", END)
graph = builder.compile(name="deep-research-agent")
























#TO DO à la fin : 
# - Tester si je peux remplacer le formattage en SearchQueries par QueryGenerationState directement, en mettant une rationale par query ? Ça allègerait la syntaxe un peu lourde du 1er node. 